### Build K-Scheduler-based libfuzzer on an example program harfbuzz
1. Build K-Scheduler-based llvm-11.0.1 following ``K-Scheduler/libfuzzer_integration/llvm_11.0.1/README.md``
2. Set up environment variable
    ```sh
    # set clang as K-Scheduler-based llvm-11.0.1
    export PATH=[path to K-Scheduler repo]/K-Scheduler/libfuzzer_integration/llvm_11.0.1/build/bin:$PATH
    # use wllvm as default compiler
    export LLVM_COMPILER=clang
    export CC=wllvm
    export CXX=wllvm++
    # Common compiler flags used in Google FuzzBench. Note that we add "-fsanitize-coverage=no-prune" to ensure a complete CFG intrumentation.
    export CXXFLAGS="-O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-coverage=no-prune -fsanitize-address-use-after-scope"
    ```
3. Build harfbuzz with K-Scheduler-based LibFuzzer following Google FuzzBench settings
    ```sh
    rm -rf BUILD
    cp -r SRC BUILD 
    # configure and build harfbuzz
    cd BUILD && ./autogen.sh && CCLD="$CXX $CXXFLAGS" ./configure --enable-static --disable-shared && make -j -C src fuzzing && cd ..
    # build harfbuzz fuzzer wrapper
    $CXX $CXXFLAGS -c -std=c++11 -I BUILD/src/ BUILD/test/fuzzing/hb-fuzzer.cc -o BUILD/test/fuzzing/hb-fuzzer.o 
    # link harfbuzz fuzzer wrapper with LibFuzzer
    $CXX $CXXFLAGS -std=c++11 -I BUILD/src/ BUILD/test/fuzzing/hb-fuzzer.o BUILD/src/.libs/libharfbuzz-fuzzing.a -fsanitize=fuzzer -lglib-2.0 -o harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler
    ```
4. Construct inter-procedural CFG for harfbuzz
    ```sh
    # extract whole-program bitcode 
    extract-bc harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler
    # convert bitcode to llvm ll code
    llvm-dis harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler.bc
    # If there exists functions with too long function name, we truncate their name with shorter hash. Becasue function with too long function names will be ignored by llvm opt CFG construction.
    python ./fix_long_fun_name.py harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler.ll
    # create directory for intra-precedural CFG
    mkdir cfg_out_harfbuzz
    cd cfg_out_harfbuzz
    # generate intra-precedural CFG using llvm opt
    opt -dot-cfg ../harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler_fix.ll
    # The intra-CFGs generated by llvm opt are stored as hidden files, rename them as normal files.
    for f in $(ls -a |grep '^\.*'|grep dot);do mv $f ${f:1};done
    # Stitch intra-CFGs into a inter-CFG following caller-callee relationships
    cd .. && python ./gen_graph.py ./harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler_fix.ll cfg_out_harfbuzz
    ```
5. Start graph analysis module 
    ```sh
    python ./gen_dyn_weight.py
    ```
6. Open another terminal, start K-Scheduler-based LibFuzzer on harfbuzz
    ```sh
    cd [path to K-Schduler repo]/K-Scheduler/libfuzzer_integration/build_example/
    # clean fuzzer corpus and other meta data generated by fuzzer
    rm -rf tmp_seeds/ cov_stats cur_coverage dyn_katz_cent 
    mkdir tmp_seeds
    # reset signal file for graph computation module
    echo 0 > signal
    # run libfuzzer_kscheduler
    ./harfbuzz-1.3.2-fsanitize_fuzzer_kscheduler -kscheduler=1 -min_num_mutations_for_each_seed=200 ./tmp_seeds/ seeds/
    ```
