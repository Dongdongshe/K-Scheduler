### Run K-Scheduler-based afl on an example proprgram harfbuzz
1. Build llvm-11.0.1 following ``K-Scheduler/libfuzzer_integration/llvm_11.0.1/README.md``. You can skip this step if you have already build llvm-11.0.1.
2. Build K-Scheduler-based afl following ``K-Scheduler/afl_integration/afl-2.52b_kscheduler/README.md``.
3. Set up environment variable and build afl runtime.
    ```sh
    # set clang as llvm-11.0.1
    export PATH=[path to K-Scheduler repo]/K-Scheduler/libfuzzer_integration/llvm_11.0.1/build/bin
    # use wllvm as default compiler, make sure you are using llvm-11.0.1
    export LLVM_COMPILER=clang 
    export CC=wllvm
    export CXX=wllvm++
    # Common compiler flags used in Google FuzzBench. Note that we add "-fsanitize-coverage=no-prune" to ensure a complete CFG intrumentation.
    export CXXFLAGS="-fsanitize-coverage=trace-pc-guard,no-prune -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope"
    # build afl runtime library
    $CC -O2 -c -w [path to K-Scheduler repo]/K-Scheduler/afl_integration/afl-2.52b_kscheduler/llvm_mode/afl-llvm-rt.o.c -o afl-llvm-rt.o
    # build afl driver
    $CXX -std=c++11 -O2 -c [path to K-Scheduler repo]/K-Scheduler/libfuzzer_integration/llvm_11.0.1/compiler-rt/lib/fuzzer/afl/afl_driver.cpp 
    ar r afl_llvm_rt_driver.a afl_driver.o afl-llvm-rt.o
    # add the absolute path afl runtime library to LDFLAGS
    export LDFLAGS=[ABSOLUTE PATH to K-Scheduler repo]/K-Scheduler/afl_integration/build_example/afl-llvm-rt.o
    ```
4. Build harfbuzz following Google FuzzBench settings
    ```sh
    rm -rf BUILD
    cp -r SRC BUILD 
    # configure and build harfbuzz
    cd BUILD && ./autogen.sh && CCLD="$CXX $CXXFLAGS" ./configure --enable-static --disable-shared && make -j -C src fuzzing && cd ..
    # build harfbuzz fuzzer wrapper
    $CXX $CXXFLAGS -c -std=c++11 -I BUILD/src/ BUILD/test/fuzzing/hb-fuzzer.cc -o BUILD/test/fuzzing/hb-fuzzer.o 
    # link harfbuzz fuzzer wrapper with afl driver
    $CXX $CXXFLAGS -std=c++11 -I BUILD/src/ BUILD/test/fuzzing/hb-fuzzer.o BUILD/src/.libs/libharfbuzz-fuzzing.a afl_llvm_rt_driver.a -lglib-2.0 -o harfbuzz_afl_asan
    ```
5. Construct inter-precedural CFG for harfbuzz
    ```sh
    # extract whole-program bitcode 
    extract-bc harfbuzz_afl_asan
    # convert bitcode to llvm ll code
    llvm-dis harfbuzz_afl_asan.bc
    # If there exists functions with too long function name, we truncate their name with shorter hash. Becasue function with too long function names will be ignored by llvm opt CFG construction.
    python ./fix_long_fun_name.py harfbuzz_afl_asan.ll
    # create directory for intra-precedural CFG
    mkdir cfg_out_harfbuzz
    cd cfg_out_harfbuzz
    # generate intra-precedural CFG using llvm opt
    opt -dot-cfg ../harfbuzz_afl_asan.ll
    # The intra-CFGs generated by llvm opt are stored as hidden files, rename them as normal files.
    for f in $(ls -a |grep '^\.*'|grep dot);do mv $f ${f:1};done
    # Stitch intra-CFGs into a inter-CFG following caller-callee relationships
    cd .. && python ./gen_graph.py ./harfbuzz_afl_asan_fix.ll cfg_out_harfbuzz
    ```
6. Start graph anlaysis module 
    ```sh
    python ./gen_dyn_weight.py
    ```
7. Open another terminal, start K-Scheduler-based afl on harfbuzz
    ```sh
    cd [path to K-Schduler repo]/K-Scheduler/afl_integration/build_example/
    # clean fuzzer corpus and other meta data generated by fuzzer
    rm -rf afl_out_* cur_coverage dyn_katz_cent
    # reset signal file for graph computation module
    echo 0 > signal
    # run libfuzzer_kscheduler
    ./afl-fuzz_kscheduler -i seeds/ -o afl_out_cent -d -m none ./harfbuzz_afl_asan @@
    ```
