### Run K-Scheduler-based qsym on an example program size
We first build binary in your host machine, then copy the binary into vagrant VM. 
1. Build llvm-11.0.1 following ``K-Scheduler/libfuzzer_integration/llvm_11.0.1/README.md``. You can skip this step if you have already build llvm-11.0.1.
2. Install python3, wllvm, then install NetworKit using pip3
3. Set up environment variable.
    ```sh
    # set clang as llvm-11.0.1
    export PATH=[path to K-Scheduler repo]/K-Scheduler/libfuzzer_integration/llvm_11.0.1/build/bin:$PATH
    # use wllvm as default compiler, make sure you are using llvm-11.0.1
    export LLVM_COMPILER=clang
    ```
4. Build size in afl mode (for code coverage instrumentation).
    ```sh
    cd [path to K-Scheduler repo]/K-Scheduler/qsym_integration/build_example/
    # copy source code directory for afl build
    cp -r binutils_src build_afl
    cd build_afl
    # configure and build
    CC=wllvm CXX=wllvm++ CFLAGS="-fsanitize-coverage=trace-pc-guard,no-prune -O2 -fsanitize=address" CXXFLAGS="-fsanitize-coverage=trace-pc-guard,no-prune -O2 -fsanitize=address" LDFLAGS=[ABSOLUTE PATH to K-Scheduler repo]/K-Scheduler/afl_integration/build_example/afl-llvm-rt.o ./configure && make -j
    # extract whole-program bitcode
    extract-bc size
    # convert bitcode to llvm ll code
    llvm-dis size.bc
    # If there exists functions with too long function name, we truncate their name with shorter hash. Becasue function with too long function names will be ignored by llvm opt CFG construction.
    cp ../fix_long_fun_name.py .
    cp ../gen_graph.py .
    python ./fix_long_fun_name.py size.ll
    # create directory for intra-precedural CFG
    mkdir cfg_out_size
    cd cfg_out_size
    # generate intra-precedural CFG using llvm opt
    opt -dot-cfg ../size_fix.ll
    # The intra-CFGs generated by llvm opt are stored as hidden files, rename them as normal files.
    for f in $(ls -a |grep '^\.*'|grep dot);do mv $f ${f:1};done
    # Stitch intra-CFGs into a inter-CFG following caller-callee relationships
    cd .. && python ./gen_graph.py ./size_fix.ll cfg_out_size
    mv size ../size_afl
    mv child_node ..
    mv parent_node ..
    mv katz_weight ..
    mv border_edges ..
    mv graph_data_pack ..
    ```
5. Build size in vanilla mode (for concolic execution)
    ```sh
    cd [path to K-Scheduler repo]/K-Scheduler/qsym_integration/build_example/
    # copy source code directory for vanilla build
    cp -r binutils_src build_vanilla
    cd build_vanilla
    CC=clang CXX=clang++ ./configure && make -j 
    mv size ../size_vanilla
    ```
6. Start graph analysis module 
    ```sh
    python3 ./gen_dyn_weight.py
    ```
7. Open another terminal, start K-Scheduler-based qsym on size
    ```sh
    cd [path to K-Schduler repo]/K-Scheduler/qsym_integration/build_example/
    # clean log files generated by qsym
    rm -rf output/* cur_coverage dyn_katz_cent edge_log signal dyn_cent_version
    # reset signal file for graph computation module
    echo 0 > signal
    # run qsym concolic execution engine
    python2 ./run_qsym_kscheduler.py -a afl-slave -o output -n qsym -- ./size_vanilla @@
    ```
